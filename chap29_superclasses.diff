diff --unified --new-file gen/chap28_methods/chunk.h gen/chap29_superclasses/chunk.h
--- gen/chap28_methods/chunk.h	2020-01-25 10:07:58.307266705 +1300
+++ gen/chap29_superclasses/chunk.h	2020-01-25 10:07:58.323274705 +1300
@@ -19,6 +19,7 @@
   OP_SET_UPVALUE,
   OP_GET_PROPERTY,
   OP_SET_PROPERTY,
+  OP_GET_SUPER,
   OP_EQUAL,
   OP_GREATER,
   OP_LESS,
@@ -34,10 +35,12 @@
   OP_LOOP,
   OP_CALL,
   OP_INVOKE,
+  OP_SUPER,
   OP_CLOSURE,
   OP_CLOSE_UPVALUE,
   OP_RETURN,
   OP_CLASS,
+  OP_INHERIT,
   OP_METHOD
 } OpCode;
 
diff --unified --new-file gen/chap28_methods/compiler.c gen/chap29_superclasses/compiler.c
--- gen/chap28_methods/compiler.c	2020-01-25 10:07:58.307266705 +1300
+++ gen/chap29_superclasses/compiler.c	2020-01-25 10:07:58.319272705 +1300
@@ -71,6 +71,7 @@
   struct ClassCompiler* enclosing;
 
   Token name;
+  bool hasSuperclass;
 } ClassCompiler;
 
 Parser parser;
@@ -482,6 +483,43 @@
 static void variable(bool canAssign) {
   namedVariable(parser.previous, canAssign);
 }
+static Token syntheticToken(const char* text) {
+  Token token;
+  token.start = text;
+  token.length = (int)strlen(text);
+  return token;
+}
+
+static void pushSuperclass() {
+  if (currentClass == NULL) return;
+  namedVariable(syntheticToken("super"), false);
+}
+
+static void super_(bool canAssign) {
+  if (currentClass == NULL) {
+    error("Cannot use 'super' outside of a class.");
+  } else if (!currentClass->hasSuperclass) {
+    error("Cannot use 'super' in a class with no superclass.");
+  }
+
+  consume(TOKEN_DOT, "Expect '.' after 'super'.");
+  consume(TOKEN_IDENTIFIER, "Expect superclass method name.");
+  uint8_t name = identifierConstant(&parser.previous);
+
+  // Push the receiver.
+  namedVariable(syntheticToken("this"), false);
+
+  if (match(TOKEN_LEFT_PAREN)) {
+    uint8_t argCount = argumentList();
+
+    pushSuperclass();
+    emitBytes(OP_SUPER, argCount);
+    emitByte(name);
+  } else {
+    pushSuperclass();
+    emitBytes(OP_GET_SUPER, name);
+  }
+}
 static void this_(bool canAssign) {
   if (currentClass == NULL) {
     error("Cannot use 'this' outside of a class.");
@@ -537,7 +575,7 @@
   { NULL,     or_,     PREC_OR },         // TOKEN_OR
   { NULL,     NULL,    PREC_NONE },       // TOKEN_PRINT
   { NULL,     NULL,    PREC_NONE },       // TOKEN_RETURN
-  { NULL,     NULL,    PREC_NONE },       // TOKEN_SUPER
+  { super_,   NULL,    PREC_NONE },       // TOKEN_SUPER
   { this_,    NULL,    PREC_NONE },       // TOKEN_THIS
   { literal,  NULL,    PREC_NONE },       // TOKEN_TRUE
   { NULL,     NULL,    PREC_NONE },       // TOKEN_VAR
@@ -638,9 +676,30 @@
 
   ClassCompiler classCompiler;
   classCompiler.name = parser.previous;
+  classCompiler.hasSuperclass = false;
   classCompiler.enclosing = currentClass;
   currentClass = &classCompiler;
 
+  if (match(TOKEN_LESS)) {
+    consume(TOKEN_IDENTIFIER, "Expect superclass name.");
+
+    if (identifiersEqual(&className, &parser.previous)) {
+      error("A class cannot inherit from itself.");
+    }
+
+    classCompiler.hasSuperclass = true;
+
+    beginScope();
+
+    // Store the superclass in a local variable named "super".
+    variable(false);
+    addLocal(syntheticToken("super"));
+    defineVariable(0);
+
+    namedVariable(className, false);
+    emitByte(OP_INHERIT);
+  }
+
   consume(TOKEN_LEFT_BRACE, "Expect '{' before class body.");
   while (!check(TOKEN_RIGHT_BRACE) && !check(TOKEN_EOF)) {
     namedVariable(className, false);
@@ -648,6 +707,10 @@
   }
   consume(TOKEN_RIGHT_BRACE, "Expect '}' after class body.");
 
+  if (classCompiler.hasSuperclass) {
+    endScope();
+  }
+
   currentClass = currentClass->enclosing;
 }
 static void funDeclaration() {
diff --unified --new-file gen/chap28_methods/debug.c gen/chap29_superclasses/debug.c
--- gen/chap28_methods/debug.c	2020-01-25 10:07:58.303264705 +1300
+++ gen/chap29_superclasses/debug.c	2020-01-25 10:07:58.319272705 +1300
@@ -83,6 +83,8 @@
       return constantInstruction("OP_GET_PROPERTY", chunk, offset);
     case OP_SET_PROPERTY:
       return constantInstruction("OP_SET_PROPERTY", chunk, offset);
+    case OP_GET_SUPER:
+      return constantInstruction("OP_GET_SUPER", chunk, offset);
     case OP_EQUAL:
       return simpleInstruction("OP_EQUAL", offset);
     case OP_GREATER:
@@ -113,6 +115,8 @@
       return byteInstruction("OP_CALL", chunk, offset);
     case OP_INVOKE:
       return invokeInstruction("OP_INVOKE", chunk, offset);
+    case OP_SUPER:
+      return invokeInstruction("OP_SUPER_", chunk, offset);
     case OP_CLOSURE: {
       offset++;
       uint8_t constant = chunk->code[offset++];
@@ -137,6 +141,8 @@
       return simpleInstruction("OP_RETURN", offset);
     case OP_CLASS:
       return constantInstruction("OP_CLASS", chunk, offset);
+    case OP_INHERIT:
+      return simpleInstruction("OP_INHERIT", offset);
     case OP_METHOD:
       return constantInstruction("OP_METHOD", chunk, offset);
     default:
diff --unified --new-file gen/chap28_methods/vm.c gen/chap29_superclasses/vm.c
--- gen/chap28_methods/vm.c	2020-01-25 10:07:58.311268705 +1300
+++ gen/chap29_superclasses/vm.c	2020-01-25 10:07:58.331278706 +1300
@@ -391,6 +391,15 @@
         break;
       }
 
+      case OP_GET_SUPER: {
+        ObjString* name = READ_STRING();
+        ObjClass* superclass = AS_CLASS(pop());
+        if (!bindMethod(superclass, name)) {
+          return INTERPRET_RUNTIME_ERROR;
+        }
+        break;
+      }
+
       case OP_EQUAL: {
         Value b = pop();
         Value a = pop();
@@ -470,6 +479,18 @@
         frame = &vm.frames[vm.frameCount - 1];
         break;
       }
+
+      case OP_SUPER: {
+        int argCount = READ_BYTE();
+        ObjString* method = READ_STRING();
+        ObjClass* superclass = AS_CLASS(pop());
+        if (!invokeFromClass(superclass, method, argCount)) {
+          return INTERPRET_RUNTIME_ERROR;
+        }
+        frame = &vm.frames[vm.frameCount - 1];
+        break;
+      }
+
       case OP_CLOSURE: {
         ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
         ObjClosure* closure = newClosure(function);
@@ -513,6 +534,19 @@
         push(OBJ_VAL(newClass(READ_STRING())));
         break;
 
+      case OP_INHERIT: {
+        Value superclass = peek(1);
+        if (!IS_CLASS(superclass)) {
+          runtimeError("Superclass must be a class.");
+          return INTERPRET_RUNTIME_ERROR;
+        }
+
+        ObjClass* subclass = AS_CLASS(peek(0));
+        tableAddAll(&AS_CLASS(superclass)->methods, &subclass->methods);
+        pop(); // Subclass.
+        break;
+      }
+
       case OP_METHOD:
         defineMethod(READ_STRING());
         break;
