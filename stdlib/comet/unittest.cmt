import 'coverage' as coverage

class Assert {
    init(value) {
        self.value = value
    }

    is_nil(message=nil) {
        if (message.nil?())
            message = String.format('expected {0} to be nil', self.value)
        assert(self.value.nil?(), message)
    }

    is_not_nil(message=nil) {
        assert(self.value.nil?() == false, message)
    }

    is_equal_to(expected, message=nil) {
        if (message.nil?())
            message = String.format('expected {0} to equal {1}', self.value, expected)
        assert(self.value == expected, message)
    }

    is_not_equal_to(expected, message=nil) {
        if (message.nil?())
            message = String.format('expected {0} to not equal {1}', self.value, expected)
        assert(self.value != expected, message)
    }

    is_true(message=nil) {
        if (message.nil?())
            message = String.format('expected {0} to be true', self.value)
        assert(self.value, message)
    }

    is_false(message=nil) {
        if (message.nil?())
            message = String.format('expected {0} to be false', self.value)
        assert(!self.value, message)
    }

    is_callable(message=nil) {
        assert(callable?(self.value))
    }

    contains(expected, message=nil) {
        assert(self.value.contains?(expected), message)
    }

    does_not_contain(expected, message=nil) {
        assert(!self.value.contains?(expected), message)
    }

    has_count(expected_count, message=nil) {
        assert(self.value.count() == expected_count, message)
    }

    matches(value, message=nil) {
        if (callable?(value)) {
            assert(value(self.value) == true, message)
        } else {
            is_equal_to(value, message)
        }
    }

    throws(message=nil) {
        if (!callable?(self.value)) {
            throw ArgumentException(String.format('throws() expects a callable to assert, but got {0}', self.value))
        }
        try {
            self.value()
            assert(false, message)
        } catch (Exception as ex) {
            if (ex is AssertionException) {
                rethrow ex
            }
            assert(true, message)
        }
    }

    does_not_throw(message=nil) {
        if (!callable?(self.value)) {
            throw ArgumentException(String.format('does_not_throw() expects a callable to assert, but got {0}', self.value))
        }
        try {
            self.value()
            assert(true, message)
        } catch (Exception as ex) {
            if (ex is AssertionException) {
                rethrow ex
            }
            assert(false, message)
        }
    }

    is_of_type(type, message=nil) {
        assert(self.value is type, message)
    }

    is_empty(message=nil) {
        assert(self.value.empty?(), message)
    }

    is_not_empty(message=nil) {
        assert(!self.value.empty?(), message)
    }

    static that(value) {
        return Assert(value)
    }

    static fail(message) {
        assert(false, message)
    }

    static pass() {}
}

if (__MAIN__ == __FILE__) {
    var tests = {}
    var total = 0
    var passed = 0
    var args = ARGV
    var generate_coverage = false
    if (ARGV[0] == '--coverage') {
        args = ARGV.slice(1)
        generate_coverage = true
    }
    foreach (var to_import in args) {
        import to_import as imported
        foreach (var func in imported.functions()) {
            if (func.name().starts_with?('test_')) {
                total += 1
                var test_name = String.format('{0}:{1}', imported.filename(), func.name())
                tests[test_name] = true
                try {
                    call_function(imported, func)
                    print(String.format('✓ {0} passed', test_name))
                    passed += 1
                } catch (Exception as ex) {
                    tests[test_name] = false
                    print(String.format('⨯ {0} failed', test_name))
                    print_to(STD_STREAM.ERR, ex.class_name(), ':')
                    print_to(STD_STREAM.ERR, ex.stacktrace)
                }
            }
        }
    }
    print(String.format('{0}/{1} tests passed', passed, total))
    if (generate_coverage) {
        coverage.generate()
    }
    if (passed != total) {
        exit(128)
    }
}
