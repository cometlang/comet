diff --unified --new-file gen/chap27_classes/chunk.h gen/chap28_methods/chunk.h
--- gen/chap27_classes/chunk.h	2020-01-25 10:07:58.287256705 +1300
+++ gen/chap28_methods/chunk.h	2020-01-25 10:07:58.307266705 +1300
@@ -33,10 +33,12 @@
   OP_JUMP_IF_FALSE,
   OP_LOOP,
   OP_CALL,
+  OP_INVOKE,
   OP_CLOSURE,
   OP_CLOSE_UPVALUE,
   OP_RETURN,
   OP_CLASS,
+  OP_METHOD
 } OpCode;
 
 typedef struct {
diff --unified --new-file gen/chap27_classes/compiler.c gen/chap28_methods/compiler.c
--- gen/chap27_classes/compiler.c	2020-01-25 10:07:58.287256705 +1300
+++ gen/chap28_methods/compiler.c	2020-01-25 10:07:58.307266705 +1300
@@ -51,6 +51,8 @@
 } Upvalue;
 typedef enum {
   TYPE_FUNCTION,
+  TYPE_INITIALIZER,
+  TYPE_METHOD,
   TYPE_SCRIPT
 } FunctionType;
 
@@ -65,10 +67,18 @@
   int scopeDepth;
 } Compiler;
 
+typedef struct ClassCompiler {
+  struct ClassCompiler* enclosing;
+
+  Token name;
+} ClassCompiler;
+
 Parser parser;
 
 Compiler* current = NULL;
 
+ClassCompiler* currentClass = NULL;
+
 static Chunk* currentChunk() {
   return &current->function->chunk;
 }
@@ -146,7 +156,13 @@
   return currentChunk()->count - 2;
 }
 static void emitReturn() {
-  emitByte(OP_NIL);
+  // An initializer automatically returns "this".
+  if (current->type == TYPE_INITIALIZER) {
+    emitBytes(OP_GET_LOCAL, 0);
+  } else {
+    emitByte(OP_NIL);
+  }
+
   emitByte(OP_RETURN);
 }
 static uint8_t makeConstant(Value value) {
@@ -189,8 +205,16 @@
   Local* local = &current->locals[current->localCount++];
   local->depth = 0;
   local->isCaptured = false;
-  local->name.start = "";
-  local->name.length = 0;
+  if (type != TYPE_FUNCTION) {
+    // In a method, it holds the receiver, "this".
+    local->name.start = "this";
+    local->name.length = 4;
+  } else {
+    // In a function, it holds the function, but cannot be referenced,
+    // so has no name.
+    local->name.start = "";
+    local->name.length = 0;
+  }
 }
 static ObjFunction* endCompiler() {
   emitReturn();
@@ -394,6 +418,10 @@
   if (canAssign && match(TOKEN_EQUAL)) {
     expression();
     emitBytes(OP_SET_PROPERTY, name);
+  } else if (match(TOKEN_LEFT_PAREN)) {
+    uint8_t argCount = argumentList();
+    emitBytes(OP_INVOKE, argCount);
+    emitByte(name);
   } else {
     emitBytes(OP_GET_PROPERTY, name);
   }
@@ -454,6 +482,13 @@
 static void variable(bool canAssign) {
   namedVariable(parser.previous, canAssign);
 }
+static void this_(bool canAssign) {
+  if (currentClass == NULL) {
+    error("Cannot use 'this' outside of a class.");
+  } else {
+    variable(false);
+  }
+}
 static void unary(bool canAssign) {
   TokenType operatorType = parser.previous.type;
 
@@ -503,7 +538,7 @@
   { NULL,     NULL,    PREC_NONE },       // TOKEN_PRINT
   { NULL,     NULL,    PREC_NONE },       // TOKEN_RETURN
   { NULL,     NULL,    PREC_NONE },       // TOKEN_SUPER
-  { NULL,     NULL,    PREC_NONE },       // TOKEN_THIS
+  { this_,    NULL,    PREC_NONE },       // TOKEN_THIS
   { literal,  NULL,    PREC_NONE },       // TOKEN_TRUE
   { NULL,     NULL,    PREC_NONE },       // TOKEN_VAR
   { NULL,     NULL,    PREC_NONE },       // TOKEN_WHILE
@@ -577,16 +612,43 @@
     emitByte(compiler.upvalues[i].index);
   }
 }
+static void method() {
+  consume(TOKEN_IDENTIFIER, "Expect method name.");
+  uint8_t constant = identifierConstant(&parser.previous);
+
+  // If the method is named "init", it's an initializer.
+  FunctionType type = TYPE_METHOD;
+  if (parser.previous.length == 4 &&
+      memcmp(parser.previous.start, "init", 4) == 0) {
+    type = TYPE_INITIALIZER;
+  }
+
+  function(type);
+
+  emitBytes(OP_METHOD, constant);
+}
 static void classDeclaration() {
   consume(TOKEN_IDENTIFIER, "Expect class name.");
+  Token className = parser.previous;
   uint8_t nameConstant = identifierConstant(&parser.previous);
   declareVariable();
 
   emitBytes(OP_CLASS, nameConstant);
   defineVariable(nameConstant);
 
+  ClassCompiler classCompiler;
+  classCompiler.name = parser.previous;
+  classCompiler.enclosing = currentClass;
+  currentClass = &classCompiler;
+
   consume(TOKEN_LEFT_BRACE, "Expect '{' before class body.");
+  while (!check(TOKEN_RIGHT_BRACE) && !check(TOKEN_EOF)) {
+    namedVariable(className, false);
+    method();
+  }
   consume(TOKEN_RIGHT_BRACE, "Expect '}' after class body.");
+
+  currentClass = currentClass->enclosing;
 }
 static void funDeclaration() {
   uint8_t global = parseVariable("Expect function name.");
@@ -689,6 +751,10 @@
   if (match(TOKEN_SEMICOLON)) {
     emitReturn();
   } else {
+    if (current->type == TYPE_INITIALIZER) {
+      error("Cannot return a value from an initializer.");
+    }
+
     expression();
     consume(TOKEN_SEMICOLON, "Expect ';' after return value.");
     emitByte(OP_RETURN);
diff --unified --new-file gen/chap27_classes/debug.c gen/chap28_methods/debug.c
--- gen/chap27_classes/debug.c	2020-01-25 10:07:58.283254705 +1300
+++ gen/chap28_methods/debug.c	2020-01-25 10:07:58.303264705 +1300
@@ -1,4 +1,5 @@
 #include <stdio.h>
+#include <string.h>
 
 #include "debug.h"
 #include "object.h"
@@ -19,6 +20,15 @@
   printf("'\n");
   return offset + 2;
 }
+static int invokeInstruction(const char* name, Chunk* chunk,
+                                int offset) {
+  uint8_t argCount = chunk->code[offset + 1];
+  uint8_t constant = chunk->code[offset + 2];
+  printf("%-16s (%d args) %4d '", name, argCount, constant);
+  printValue(chunk->constants.values[constant]);
+  printf("'\n");
+  return offset + 2;
+}
 static int simpleInstruction(const char* name, int offset) {
   printf("%s\n", name);
   return offset + 1;
@@ -101,6 +111,8 @@
       return jumpInstruction("OP_LOOP", -1, chunk, offset);
     case OP_CALL:
       return byteInstruction("OP_CALL", chunk, offset);
+    case OP_INVOKE:
+      return invokeInstruction("OP_INVOKE", chunk, offset);
     case OP_CLOSURE: {
       offset++;
       uint8_t constant = chunk->code[offset++];
@@ -125,6 +137,8 @@
       return simpleInstruction("OP_RETURN", offset);
     case OP_CLASS:
       return constantInstruction("OP_CLASS", chunk, offset);
+    case OP_METHOD:
+      return constantInstruction("OP_METHOD", chunk, offset);
     default:
       printf("Unknown opcode %d\n", instruction);
       return offset + 1;
diff --unified --new-file gen/chap27_classes/memory.c gen/chap28_methods/memory.c
--- gen/chap27_classes/memory.c	2020-01-25 10:07:58.291258704 +1300
+++ gen/chap28_methods/memory.c	2020-01-25 10:07:58.307266705 +1300
@@ -69,9 +69,17 @@
 #endif
 
   switch (object->type) {
+    case OBJ_BOUND_METHOD: {
+      ObjBoundMethod* bound = (ObjBoundMethod*)object;
+      markValue(bound->receiver);
+      markObject((Obj*)bound->method);
+      break;
+    }
+
     case OBJ_CLASS: {
       ObjClass* klass = (ObjClass*)object;
       markObject((Obj*)klass->name);
+      markTable(&klass->methods);
       break;
     }
 
@@ -113,7 +121,13 @@
 #endif
 
   switch (object->type) {
+    case OBJ_BOUND_METHOD:
+      FREE(ObjBoundMethod, object);
+      break;
+
     case OBJ_CLASS: {
+      ObjClass* klass = (ObjClass*)object;
+      freeTable(&klass->methods);
       FREE(ObjClass, object);
       break;
     } // [braces]
@@ -172,6 +186,7 @@
 
   markTable(&vm.globals);
   markCompilerRoots();
+  markObject((Obj*)vm.initString);
 }
 static void traceReferences() {
   while (vm.grayCount > 0) {
diff --unified --new-file gen/chap27_classes/object.c gen/chap28_methods/object.c
--- gen/chap27_classes/object.c	2020-01-25 10:07:58.291258704 +1300
+++ gen/chap28_methods/object.c	2020-01-25 10:07:58.307266705 +1300
@@ -24,9 +24,19 @@
 
   return object;
 }
+
+ObjBoundMethod* newBoundMethod(Value receiver, ObjClosure* method) {
+  ObjBoundMethod* bound = ALLOCATE_OBJ(ObjBoundMethod,
+                                       OBJ_BOUND_METHOD);
+
+  bound->receiver = receiver;
+  bound->method = method;
+  return bound;
+}
 ObjClass* newClass(ObjString* name) {
   ObjClass* klass = ALLOCATE_OBJ(ObjClass, OBJ_CLASS);
   klass->name = name; // [klass]
+  initTable(&klass->methods);
   return klass;
 }
 ObjClosure* newClosure(ObjFunction* function) {
@@ -127,6 +137,9 @@
     case OBJ_CLASS:
       printf("%s", AS_CLASS(value)->name->chars);
       break;
+    case OBJ_BOUND_METHOD:
+      printFunction(AS_BOUND_METHOD(value)->method->function);
+      break;
     case OBJ_CLOSURE:
       printFunction(AS_CLOSURE(value)->function);
       break;
diff --unified --new-file gen/chap27_classes/object.h gen/chap28_methods/object.h
--- gen/chap27_classes/object.h	2020-01-25 10:07:58.283254705 +1300
+++ gen/chap28_methods/object.h	2020-01-25 10:07:58.303264705 +1300
@@ -8,6 +8,7 @@
 
 #define OBJ_TYPE(value)         (AS_OBJ(value)->type)
 
+#define IS_BOUND_METHOD(value)  isObjType(value, OBJ_BOUND_METHOD)
 #define IS_CLASS(value)         isObjType(value, OBJ_CLASS)
 #define IS_CLOSURE(value)       isObjType(value, OBJ_CLOSURE)
 #define IS_FUNCTION(value)      isObjType(value, OBJ_FUNCTION)
@@ -15,6 +16,7 @@
 #define IS_NATIVE(value)        isObjType(value, OBJ_NATIVE)
 #define IS_STRING(value)        isObjType(value, OBJ_STRING)
 
+#define AS_BOUND_METHOD(value)  ((ObjBoundMethod*)AS_OBJ(value))
 #define AS_CLASS(value)         ((ObjClass*)AS_OBJ(value))
 #define AS_CLOSURE(value)       ((ObjClosure*)AS_OBJ(value))
 #define AS_FUNCTION(value)      ((ObjFunction*)AS_OBJ(value))
@@ -24,6 +26,7 @@
 #define AS_CSTRING(value)       (((ObjString*)AS_OBJ(value))->chars)
 
 typedef enum {
+  OBJ_BOUND_METHOD,
   OBJ_CLASS,
   OBJ_CLOSURE,
   OBJ_FUNCTION,
@@ -76,6 +79,7 @@
 typedef struct sObjClass {
   Obj obj;
   ObjString* name;
+  Table methods;
 } ObjClass;
 
 typedef struct {
@@ -84,6 +88,13 @@
   Table fields; // [fields]
 } ObjInstance;
 
+typedef struct {
+  Obj obj;
+  Value receiver;
+  ObjClosure* method;
+} ObjBoundMethod;
+
+ObjBoundMethod* newBoundMethod(Value receiver, ObjClosure* method);
 ObjClass* newClass(ObjString* name);
 ObjClosure* newClosure(ObjFunction* function);
 ObjFunction* newFunction();
diff --unified --new-file gen/chap27_classes/vm.c gen/chap28_methods/vm.c
--- gen/chap27_classes/vm.c	2020-01-25 10:07:58.299262705 +1300
+++ gen/chap28_methods/vm.c	2020-01-25 10:07:58.311268705 +1300
@@ -64,12 +64,15 @@
   initTable(&vm.globals);
   initTable(&vm.strings);
 
+  vm.initString = copyString("init", 4);
+
   defineNative("clock", clockNative);
 }
 
 void freeVM() {
   freeTable(&vm.globals);
   freeTable(&vm.strings);
+  vm.initString = NULL;
   freeObjects();
 }
 void push(Value value) {
@@ -105,9 +108,27 @@
 static bool callValue(Value callee, int argCount) {
   if (IS_OBJ(callee)) {
     switch (OBJ_TYPE(callee)) {
+      case OBJ_BOUND_METHOD: {
+        ObjBoundMethod* bound = AS_BOUND_METHOD(callee);
+
+        // Replace the bound method with the receiver so it's in the
+        // right slot when the method is called.
+        vm.stackTop[-argCount - 1] = bound->receiver;
+        return call(bound->method, argCount);
+      }
+
       case OBJ_CLASS: {
         ObjClass* klass = AS_CLASS(callee);
         vm.stackTop[-argCount - 1] = OBJ_VAL(newInstance(klass));
+        // Call the initializer, if there is one.
+        Value initializer;
+        if (tableGet(&klass->methods, vm.initString, &initializer)) {
+          return call(AS_CLOSURE(initializer), argCount);
+        } else if (argCount != 0) {
+          runtimeError("Expected 0 arguments but got %d.", argCount);
+          return false;
+        }
+
         return true;
       }
       case OBJ_CLOSURE:
@@ -130,6 +151,53 @@
   runtimeError("Can only call functions and classes.");
   return false;
 }
+
+static bool invokeFromClass(ObjClass* klass, ObjString* name,
+                            int argCount) {
+  // Look for the method.
+  Value method;
+  if (!tableGet(&klass->methods, name, &method)) {
+    runtimeError("Undefined property '%s'.", name->chars);
+    return false;
+  }
+
+  return call(AS_CLOSURE(method), argCount);
+}
+
+static bool invoke(ObjString* name, int argCount) {
+  Value receiver = peek(argCount);
+
+  if (!IS_INSTANCE(receiver)) {
+    runtimeError("Only instances have methods.");
+    return false;
+  }
+
+  ObjInstance* instance = AS_INSTANCE(receiver);
+
+  // First look for a field which may shadow a method.
+  Value value;
+  if (tableGet(&instance->fields, name, &value)) {
+    // Load the field onto the stack in place of the receiver.
+    vm.stackTop[-argCount - 1] = value;
+    // Try to invoke it like a function.
+    return callValue(value, argCount);
+  }
+
+  return invokeFromClass(instance->klass, name, argCount);
+}
+
+static bool bindMethod(ObjClass* klass, ObjString* name) {
+  Value method;
+  if (!tableGet(&klass->methods, name, &method)) {
+    runtimeError("Undefined property '%s'.", name->chars);
+    return false;
+  }
+
+  ObjBoundMethod* bound = newBoundMethod(peek(0), AS_CLOSURE(method));
+  pop(); // Instance.
+  push(OBJ_VAL(bound));
+  return true;
+}
 static ObjUpvalue* captureUpvalue(Value* local) {
   ObjUpvalue* prevUpvalue = NULL;
   ObjUpvalue* upvalue = vm.openUpvalues;
@@ -161,6 +229,14 @@
     vm.openUpvalues = upvalue->next;
   }
 }
+
+static void defineMethod(ObjString* name) {
+  Value method = peek(0);
+  ObjClass* klass = AS_CLASS(peek(1));
+  tableSet(&klass->methods, name, method);
+  pop();
+  pop();
+}
 static bool isFalsey(Value value) {
   return IS_NIL(value) || (IS_BOOL(value) && !AS_BOOL(value));
 }
@@ -294,8 +370,10 @@
           break;
         }
 
-        runtimeError("Undefined property '%s'.", name->chars);
-        return INTERPRET_RUNTIME_ERROR;
+        if (!bindMethod(instance->klass, name)) {
+          return INTERPRET_RUNTIME_ERROR;
+        }
+        break;
       }
 
       case OP_SET_PROPERTY: {
@@ -383,6 +461,15 @@
         break;
       }
 
+      case OP_INVOKE: {
+        int argCount = READ_BYTE();
+        ObjString* method = READ_STRING();
+        if (!invoke(method, argCount)) {
+          return INTERPRET_RUNTIME_ERROR;
+        }
+        frame = &vm.frames[vm.frameCount - 1];
+        break;
+      }
       case OP_CLOSURE: {
         ObjFunction* function = AS_FUNCTION(READ_CONSTANT());
         ObjClosure* closure = newClosure(function);
@@ -425,6 +512,10 @@
       case OP_CLASS:
         push(OBJ_VAL(newClass(READ_STRING())));
         break;
+
+      case OP_METHOD:
+        defineMethod(READ_STRING());
+        break;
     }
   }
 
diff --unified --new-file gen/chap27_classes/vm.h gen/chap28_methods/vm.h
--- gen/chap27_classes/vm.h	2020-01-25 10:07:58.287256705 +1300
+++ gen/chap28_methods/vm.h	2020-01-25 10:07:58.307266705 +1300
@@ -22,6 +22,7 @@
   Value* stackTop;
   Table globals;
   Table strings;
+  ObjString* initString;
   ObjUpvalue* openUpvalues;
 
   size_t bytesAllocated;
